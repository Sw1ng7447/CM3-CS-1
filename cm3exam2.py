# -*- coding: utf-8 -*-
"""CM3Exam2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rcqmZjAi96rpXz82CYeCwrreGMIOg-Eu

# Exam 2: Final Exam

Your job is to implement a Python Class for a data-structure called a ring buffer which has the property shown below: when it overflows its size, the next element goes into the first position. You will then use this buffer to implement a financial trading system

![](https://i.imgur.com/Tv80asJ.png)

### Q1. Implement a ring buffer

Implement a RingBuffer class. The ring buffer should have a specified maximum size and should overwrite the oldest data when full.

Required methods:
- `__init__(size)`: Initialize buffer with given maximum size
- `add(value)`: Add a new value to the buffer
- `get_inorder()`: Return all current values in order of addition
- `get_all()`: Get the buffer
- `is_full()`: Return True if buffer is full
- `current_size()`: Return number of elements currently in buffer

Look for `# your code here` in the code below and fill it in.
"""

class RingBuffer:
    def __init__(self, size):
        self.size = size
        self.buffer = [None] * size # using a list with size Nones as storage
        self.current = 0  # Position to write next item
        self.is_filled = False

    def add(self, value):
        # Add new value to buffer
        self.buffer[self.current] = value

        # Update position for next write
        # make sure you take the finite size into account


        # Check if we've filled the buffer at least once
        if self.current == 0:
            self.is_filled = True

    def get_inorder(self):
        if not self.is_filled:
            # If we haven't filled the buffer yet, return only up to current
            return [x for x in self.buffer[:self.current] if x is not None]
        else:
            # Return complete circular queue starting from oldest value
            return self.buffer[self.current:] + self.buffer[:self.current]

    def get_all(self):
        # your code here. Handle the case when the buffer is not yet filled

    def is_full(self):
        # your code here

    def current_size(self):
        # your code here

"""If your code is correct there should be no errors in the next cell."""

def test_ring_buffer():
    print("Testing RingBuffer implementation...")

    # Test initialization
    buffer = RingBuffer(3)
    assert buffer.size == 3, "Buffer size should be 3"
    assert buffer.current == 0, "Initial position should be 0"
    assert buffer.is_filled == False, "Buffer should not be marked as filled initially"
    assert buffer.get_all() == [], "New buffer should be empty"

    # Test adding single element
    buffer.add(1)
    assert buffer.current == 1, "Current should be 1 after adding one element"
    assert buffer.get_all() == [1], "Buffer should contain only [1]"
    assert buffer.current_size() == 1, "Current size should be 1"
    assert buffer.is_full() == False, "Buffer should not be full"

    # Test adding elements up to buffer size
    buffer.add(2)
    buffer.add(3)
    assert buffer.get_inorder() == [1, 2, 3], "Buffer should have added [1, 2, 3]"
    assert buffer.get_all() == [1, 2, 3], "Buffer should be [1, 2, 3]"
    assert buffer.current == 0, "Current should wrap to 0"
    assert buffer.is_filled == True, "Buffer should be marked as filled"
    assert buffer.current_size() == 3, "Current size should be 3"
    assert buffer.is_full() == True, "Buffer should be full"

    # Test overwriting elements
    buffer.add(4)
    assert buffer.get_inorder() == [2, 3, 4], "Buffer should contain [4, 2, 3]"
    assert buffer.get_all() == [4, 2, 3], "Buffer should contain [4, 2, 3]"
    buffer.add(5)
    assert buffer.get_inorder() == [3, 4, 5], "Buffer should contain [4, 2, 3]"
    assert buffer.get_all() == [4, 5, 3], "Buffer should contain [4, 5, 3]"
    buffer.add(6)
    assert buffer.get_inorder() == [4, 5, 6], "Buffer should contain [4, 2, 3]"
    assert buffer.get_all() == [4, 5, 6], "Buffer should contain [4, 5, 6]"

    # Test buffer maintains size
    assert len(buffer.get_all()) == 3, "Buffer should maintain size of 3"

    # Edge cases
    # Test buffer of size 1
    single_buffer = RingBuffer(1)
    single_buffer.add(1)
    assert single_buffer.get_all() == [1], "Single-size buffer should contain [1]"
    single_buffer.add(2)
    assert single_buffer.get_all() == [2], "Single-size buffer should contain [2]"

    print("all test cases passed")

test_ring_buffer()

"""### Q2. Implement a moving average class

We will implement a moving average based on this ring buffer

![](https://i.imgur.com/YFgkhKK.png)
"""

class MovingAverageCalculator:
    def __init__(self, window_size):
        self.buffer = RingBuffer(window_size)

    def add_number(self, value):
        self.buffer.add(value)

    def get_average(self):
        # get values from buffer
        # your code here, get values from buffer
        values =
        # error handling
        if not values:
            raise ValueError("No numbers added yet")
        # Calculate the average
        # your code here
        average =
        return average


# Test cases
def test_moving_average():
    calc = MovingAverageCalculator(3)

    # Test with initial filling
    calc.add_number(1)
    assert calc.get_average() == 1

    calc.add_number(2)
    assert abs(calc.get_average() - 1.5) < 1e-10

    calc.add_number(3)
    assert abs(calc.get_average() - 2.0) < 1e-10

    # Test with buffer full (cycling): now we have 4,2,3
    calc.add_number(4)
    assert abs(calc.get_average() - 3.0) < 1e-10

    print("All test cases passed!")
test_moving_average()

"""### Q3: Now for the last part. We are going to implement a trading system.

Your job is to simply implement trading signals on buying and selling.

![](https://i.imgur.com/ZObWJoe.png)
"""

class TradingSystem:
    def __init__(self, history_size=100, short_ma_size=20, long_ma_size=50):
        # All three ring buffers
        self.price_history = RingBuffer(history_size)
        self.short_ma = MovingAverageCalculator(short_ma_size)  # Contains its own ring buffer
        self.long_ma = MovingAverageCalculator(long_ma_size)    # Contains its own ring buffer

    def add_price(self, price):
        # Each add_price updates all three buffers
        self.price_history.add(price)         # First buffer
        self.short_ma.add_number(price)       # Second buffer (inside MovingAverageCalculator)
        self.long_ma.add_number(price)        # Third buffer (inside MovingAverageCalculator)

    def get_state(self):
        """Get current state of all three buffers"""
        try:
            return {
                'current_price': self.price_history.get_all()[-1],
                'short_ma': self.short_ma.get_average(),
                'long_ma': self.long_ma.get_average(),
                'price_history': self.price_history.get_all()
            }
        except (IndexError, ValueError):
            return "Insufficient data"

    def get_signal(self):
        """Generate trading signal based on MA crossover"""
        try:
            # return "BUY" if short term average is greater than long term
            # return "SELL" if opposite and "HOLD" if equal
            # your code here


        except ValueError:
            return "HOLD"  # Not enough data yet

def demonstrate_triple_buffer():
    """Show how the three buffers work together"""
    trading = TradingSystem(history_size=5, short_ma_size=3, long_ma_size=4)

    print("Demonstrating triple buffer trading system:")
    prices = [100, 101, 99, 102, 98, 103]

    for price in prices:
        trading.add_price(price)
        state = trading.get_state()
        if isinstance(state, dict):
            print(f"\nNew price added: {price}")
            print(f"Price History: {state['price_history']}")
            print(f"Short MA: {state['short_ma']:.2f}")
            print(f"Long MA: {state['long_ma']:.2f}")
            print(f"Signal: {trading.get_signal()}")

demonstrate_triple_buffer()

"""Your output should look like this:

```
Demonstrating triple buffer trading system:

New price added: 100
Price History: [100]
Short MA: 100.00
Long MA: 100.00
Signal: HOLD

New price added: 101
Price History: [100, 101]
Short MA: 100.50
Long MA: 100.50
Signal: HOLD

New price added: 99
Price History: [100, 101, 99]
Short MA: 100.00
Long MA: 100.00
Signal: HOLD

New price added: 102
Price History: [100, 101, 99, 102]
Short MA: 100.67
Long MA: 100.50
Signal: BUY

New price added: 98
Price History: [100, 101, 99, 102, 98]
Short MA: 99.67
Long MA: 100.00
Signal: SELL

New price added: 103
Price History: [103, 101, 99, 102, 98]
Short MA: 101.00
Long MA: 100.50
Signal: BUY
```
"""

